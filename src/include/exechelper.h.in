/* 
    2015 (c) Steve Dodier-Lazaro <sidnioulz@gmail.com>
    This file is part of ExecHelper.

    ExecHelper is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ExecHelper is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ExecHelper.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __EH_EXECHELP_H__
#define __EH_EXECHELP_H__

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include "exechelper-datatypes.h"

/* Debug macros */
#ifndef DEBUGLVL
#define DEBUGLVL 2
#endif

extern int arg_debug;

/* Constants */
#define EXECHELP_NULL_BINARY_PATH         "/dev/null"

#define EXECHELP_LINKED_APPS              "linked-apps.list"
#define EXECHELP_PROTECTED_APPS           "protected-apps.list"
#define EXECHELP_WHITELIST_FILES          "whitelist-files.list"
#define EXECHELP_WHITELIST_APPS           "whitelist-apps.list"
#define EXECHELP_PROTECTED_FILES          "protected-files.list"
#define EXECHELP_PROTECTED_APPS_BIN       "protected-apps.policy"
#define EXECHELP_PROTECTED_FILES_BIN      "protected-files.policy"

#define EXECHELP_CLIENT_ROOT              "/etc/firejail/self"
#define EXECHELP_LINKED_APPS_PATH         EXECHELP_CLIENT_ROOT"/"EXECHELP_LINKED_APPS
#define EXECHELP_PROTECTED_APPS_PATH      EXECHELP_CLIENT_ROOT"/"EXECHELP_PROTECTED_APPS
#define EXECHELP_PROTECTED_FILES_PATH     EXECHELP_CLIENT_ROOT"/"EXECHELP_PROTECTED_FILES
#define EXECHELP_WHITELIST_APPS_PATH      EXECHELP_CLIENT_ROOT"/"EXECHELP_WHITELIST_APPS
#define EXECHELP_WHITELIST_FILES_PATH     EXECHELP_CLIENT_ROOT"/"EXECHELP_WHITELIST_FILES

#define EXECHELP_GENERATED_POLICY_HEADER  "# This file is automatically generated by Firejail\n" \
                                          "#\n# Edit with caution, and make sure not to add trailing dashes to folder names"

#define EXECHELP_LD_PRELOAD_PATH          "@prefix@/lib/firejail/libexechelper.so:@prefix@/lib/firejail/libexechelperdecorations.so"
#define EXECHELP_LD_PRELOAD_DECO_ONLY     "@prefix@/lib/firejail/libexechelperdecorations.so"

#define EXECHELP_RUN_DIR                  "/run/firejail"
#define EXECHELP_REGISTRATION_SOCKET      "/run/firejail/execd-register.sock"
#define EXECHELP_COMMANDS_SOCKET          "EXECHELP_COMMANDS_SOCKET"
#define EXECHELP_EXECUTION_POLICY         "EXECHELP_EXECUTION_POLICY"
// 256 for each socket path, 12 for the pid, 12 for the message syntax
#define EXECHELP_REGISTRATION_MSGLEN      (512 + 12 + 20)
#define EXECHELP_COMMAND_MAXLEN           92000
#define EXECHELP_POLICY_LINE_MAX_READ     8192

#define NET_CLEANUP_FILE                  "network-cleanup.sh"

#define EXECHELP_COMMAND_ANY              "*"
#define EXECHELP_PROFILE_ANY              "*"
#define EXECHELP_PROFILE_NONE             "UNSANDBOXED"

#define EXECHELP_SANDBOX_TYPE_ENV         "FIREJAIL_SANDBOX_TYPE"
#define EXECHELP_SANDBOX_NAME_ENV         "FIREJAIL_SANDBOX_NAME"
#define EXECHELP_DEBUG_ENV                "EXECHELP_DEBUG"

#define EXECHELP_DEFAULT_USER_PROFILE	     "generic"
#define EXECHELP_DEFAULT_ROOT_PROFILE      "server"

// legacy + internal
#define DEFAULT_USER_PROFILE	"generic"
#define DEFAULT_ROOT_PROFILE	"server"



/* Execution policy */
typedef enum _ExecHelpExecutionPolicy {
  LINKED_APP = 1,
  UNSPECIFIED = 1 << 1,
  SANDBOX_PROTECTED = 1 << 2,
  SANDBOX_ITSELF = 1 << 3
} ExecHelpExecutionPolicy;
#define EXECHELP_DEFAULT_POLICY           LINKED_APP | UNSPECIFIED



/* Construct directories for fireexecd / libexechelper IPC */
void exechelp_build_run_dir(void);



/* Client utilities to use only with list-type files */
char *exechelp_read_list_from_file(const char *file_path);
int exechelp_str_has_prefix_on_sep(const char *str, const char *prefix, const char sep);
int exechelp_file_list_contains_path(const char *list, const char *real, char **prefix);
int exechelp_file_list_contains_path_comma(const char *list, const char *real, char **prefix);
ExecHelpExecutionPolicy *exechelp_targets_sandbox_protected_file(const char *filepath, const char *target, char *const argv[], int whitelist, char **forbiddenpaths);



/* Binary association structure for linked apps */
typedef struct _ExecHelpBinaryAssociations {
  ExecHelpSList     *assoc;
  ExecHelpHashTable *index;
} ExecHelpBinaryAssociations;

ExecHelpBinaryAssociations *exechelp_get_binary_associations();
ExecHelpSList *exechelp_get_associations_for_main_binary(ExecHelpBinaryAssociations *assoc, const char *mainkey);
ExecHelpSList *exechelp_get_associations_for_arbitrary_binary(ExecHelpBinaryAssociations *assoc, const char *key);
int exechelp_is_associated_app(const char *caller, const char *callee);
char *exechelp_extract_associations_for_binary(const char *receiving_binary);



/* Memory functions */
void *exechelp_malloc0(size_t size);
void *exechelp_memdup (const void *mem, unsigned int byte_size);



/* General utilities */
char *exechelp_resolve_executable_path(const char *target);
pid_t exechelp_fork(void);



/* realpath - print the resolved path
 * Copyright (C) 2011-2015 Free Software Foundation, Inc.
 * Written by PÃ¡draig Brady. */
char *exechelp_coreutils_areadlink_with_size(char const *file, size_t size);
char *exechelp_coreutils_realpath (const char *fname);



/* Protected-files.policy parsing for third-party clients and for fireexecd */
typedef struct _ExecHelpProtectedFileHandler {
  char *profile_name;
  char *handler_path;
} ExecHelpProtectedFileHandler;

/** @fn protected_files_parse
 * @brief Finds a file containing a policy for Firejail protected files, and
 * extracts information from it one line at a time (call recursively with the
 * same pointer to go through the whole file).
 *
 * @param fp: placeholder for a pointer to the file being parsed. Must be NULL
 * on start, will be set to NULL on end or error
 * @param lineno: placeholder for the number of the line being parsed
 * @param path: placeholder for the file path of the line being parsed
 * @param profiles: placeholder for the profile string of the line being parsed,
 * pass to parse_profile_string() to process it.
 *
 * @returns: 0 if no error occurred, -1 if a fatal error occurred, -2 if the
 * current line could not be parsed, -3 if no file could be found. Upon fatal or
 * file errors, fp is set to NULL. Check for fp to detect termination, and check
 * that the return value is equal to 0 to decide to process the current line.
 * You must free path and profiles's content every time this function returns 0.
 */
int protected_files_parse (FILE **fp, int *lineno, char **path, char **profiles);
int protected_files_parse_handler (char *list, char **endptr, ExecHelpProtectedFileHandler **handler);

/* Protected File handler format (handler path + profile name) */
ExecHelpProtectedFileHandler *protected_files_handler_new (char *handler, char *profile);
ExecHelpProtectedFileHandler *protected_files_handler_copy (const ExecHelpProtectedFileHandler *other, void *);
int protected_files_handler_cmp (const ExecHelpProtectedFileHandler *a, const ExecHelpProtectedFileHandler *b);
void protected_files_handler_free (ExecHelpProtectedFileHandler *handler);
ExecHelpList *protected_files_get_handlers_for_file (const char *file);

typedef enum {
  HANDLER_IDENTICAL,
  HANDLER_USE_MERGED,
  HANDLER_UNMERGEABLE,
  HANDLER_MERGE_ERROR,
  HANDLER_MERGE_LAST
} ExecHelpHandlerMergeResult;

ExecHelpHandlerMergeResult protected_files_handlers_merge(const ExecHelpProtectedFileHandler *a,
                                                          const ExecHelpProtectedFileHandler *b,
                                                          ExecHelpProtectedFileHandler **placeholder);

/* Saving protected-files.policy files */
int protected_files_save_start (FILE **fp);
int protected_files_save_add_file_start (FILE **fp, const char *file);
int protected_files_save_add_file_add_handler (FILE **fp, const char *handler, const char *profile, int index);
int protected_files_save_add_file_finish (FILE **fp);
int protected_files_save_finish (FILE **fp);

/* for internal use, do not call yourself -- may inject a '\0' into string */
int exechelp_parse_get_next_separator(char *string, char **sep, int insert_nul);

#endif /* __EH_EXECHELP_H__ */
